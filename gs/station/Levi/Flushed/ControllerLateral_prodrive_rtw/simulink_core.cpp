#include <cstring>
#include <stdio.h>
#include <string>

// Prodrive Motion Platform Simulink includes
#include "dynamiclibrary_create.h"
#include "stdlib_proxy.h"
#include "dynamiclibrary_callbacks.h"
#include "simulink_library.h"
#include "dynamiclibrary_simulink.h"

extern "C" {

#include "events.h"
#include "ControllerLateral.h"
#include "ControllerLateral_types.h"
#include "ControllerLateral_private.h"

}
// The std_proxy does not work for:
// - Windows simulator (dll)
// - HW (statically linked)
// To overcome the leaks for memory allocated in this file, the memory allocation functions are directly mapped on the callback functions
// Allocations are typically done in this file
// Memory allocated in other files generated by simulink still suffer on these platforms from leaks
#define free(arg)                      PmpInternal::DynamicLibrary::libCallbacks.free(PmpInternal::DynamicLibrary::libCallbacks.handle, arg)
#define malloc(size)                   PmpInternal::DynamicLibrary::libCallbacks.malloc(PmpInternal::DynamicLibrary::libCallbacks.handle, size)
#define calloc(nmemb, size)            PmpInternal::DynamicLibrary::libCallbacks.calloc(PmpInternal::DynamicLibrary::libCallbacks.handle, nmemb, size)
#define realloc(ptr, size)             PmpInternal::DynamicLibrary::libCallbacks.realloc(PmpInternal::DynamicLibrary::libCallbacks.handle, ptr, size)

namespace PmpInternal
{
  namespace DynamicLibrary
  {
    static void ClearDWork(void* ptr, int value, size_t num);
    struct SNamedSignalInfo
    {
      const char * Name;
      PmpInternal::DynamicLibrary::SSignalInfo Info;
    };

    struct SNamedEventInfo
    {
      const char * Name;
      PmpInternal::DynamicLibrary::SEventInfo Info;
    };

    struct CSimulinkCoreControllerLateral: public PmpInternal::DynamicLibrary::
      ISimulink
    {
      SEventSet events;
      void * modelData;
      CSimulinkCoreControllerLateral(void * modelData);
      void * operator new(size_t size)
      {
        return malloc(size);
      }

      void operator delete(void * p)
      {
        free(p);
      }
    };

    static void CSimulinkCoreControllerLateral_SetInputsDataAddress(PmpInternal::
      DynamicLibrary::ISimulink* intf, void* address)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral* >(intf);
      rtmSetU((RT_MODEL_ControllerLateral_T*) self->modelData,
              (ExtU_ControllerLateral_T*) address);
    }

    static void CSimulinkCoreControllerLateral_SetOutputsDataAddress(PmpInternal::
      DynamicLibrary::ISimulink* intf, void* address)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      rtmSetY((RT_MODEL_ControllerLateral_T*) self->modelData,
              (ExtY_ControllerLateral_T*) address);
    }

    static void CSimulinkCoreControllerLateral_SetTestpointsDataAddress
      (PmpInternal::DynamicLibrary::ISimulink* intf, void* address)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      rtmSetBlockIO((RT_MODEL_ControllerLateral_T*) self->modelData,
                    (B_ControllerLateral_T*) address);
    }

    static void CSimulinkCoreControllerLateral_SetUpdatableDataAddress
      (PmpInternal::DynamicLibrary::ISimulink*, const char*, void*)
    {
    }

    static void CSimulinkCoreControllerLateral_SetModelUpdatableDefaults
      (PmpInternal::DynamicLibrary::ISimulink*, void*)
    {
    }

    static void CSimulinkCoreControllerLateral_SetParametersDataAddress
      (PmpInternal::DynamicLibrary::ISimulink* intf, void* address)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      rtmSetControllerLateral_InstP_ref((RT_MODEL_ControllerLateral_T*)
        self->modelData, (InstP_ControllerLateral_T*) address);

      // Copy in default parameter data
      (void) memcpy(rtmGetControllerLateral_InstP_ref
                    ((RT_MODEL_ControllerLateral_T*) self->modelData),
                    &ControllerLateral_InstP, sizeof(InstP_ControllerLateral_T));
      CSimulinkCoreControllerLateral_SetModelUpdatableDefaults(self,
        self->modelData);
    }

    static void CSimulinkCoreControllerLateral_SetEventsDataAddress(PmpInternal::
      DynamicLibrary::ISimulink*, void*)
    {
    }

    static uint32_t CSimulinkCoreControllerLateral_GetStateDataSize(PmpInternal::
      DynamicLibrary::ISimulink*)
    {
      return sizeof(DW_ControllerLateral_T);
    }

    static void CSimulinkCoreControllerLateral_SetStateDataAddress(PmpInternal::
      DynamicLibrary::ISimulink* intf, void* address)
    {
      memset(address, 0, CSimulinkCoreControllerLateral_GetStateDataSize(intf));
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      rtmSetRootDWork((RT_MODEL_ControllerLateral_T*) self->modelData,
                      (DW_ControllerLateral_T*) address);
    }

    static void CSimulinkCoreControllerLateral_Init(PmpInternal::DynamicLibrary::
      ISimulink* intf, void* handle)
    {
      PmpInternal::DynamicLibrary::libCallbacks.handle = handle;
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      RT_MODEL_ControllerLateral_T* ControllerLateral_M =
        (RT_MODEL_ControllerLateral_T*) self->modelData;
      B_ControllerLateral_T *ControllerLateral_B = ControllerLateral_M->blockIO;
      DW_ControllerLateral_T *ControllerLateral_DW = ControllerLateral_M->dwork;
      PrevZCX_ControllerLateral_T *ControllerLateral_PrevZCX =
        ControllerLateral_M->prevZCSigState;
      ExtU_ControllerLateral_T *ControllerLateral_U = (ExtU_ControllerLateral_T *)
        ControllerLateral_M->inputs;
      ExtY_ControllerLateral_T *ControllerLateral_Y = (ExtY_ControllerLateral_T *)
        ControllerLateral_M->outputs;

      /* initialize non-finites */
      rt_InitInfAndNaN(sizeof(real_T));

      /* block I/O */
      (void) memset(((void *) ControllerLateral_B), 0,
                    sizeof(B_ControllerLateral_T));

      {
        ControllerLateral_B->Tsamp = 0.0;
        ControllerLateral_B->Product1 = 0.0;
        ControllerLateral_B->NProdOut = 0.0;
        ControllerLateral_B->Tsamp_c = 0.0;
        ControllerLateral_B->NProdOut_k = 0.0;
        ControllerLateral_B->Delay1 = 0.0;
        ControllerLateral_B->Delay = 0.0;
        ControllerLateral_B->Switch4 = 0.0;
        ControllerLateral_B->Switch3 = 0.0;
        ControllerLateral_B->Switch5 = 0.0;
        ControllerLateral_B->Delay1_f = 0.0;
        ControllerLateral_B->Delay_d = 0.0;
        ControllerLateral_B->Switch4_b = 0.0;
        ControllerLateral_B->Switch3_m = 0.0;
        ControllerLateral_B->Switch5_e = 0.0;
        ControllerLateral_B->Switch = 0.0;
        ControllerLateral_B->Switch_a = 0.0;
        ControllerLateral_B->SumI4 = 0.0;
        ControllerLateral_B->SumI4_e = 0.0;
        ControllerLateral_B->Gain3_i = 0.0;
        ControllerLateral_B->Gain10 = 0.0;
        ControllerLateral_B->diff2 = 0.0;
        ControllerLateral_B->FilterCoefficient = 0.0;
        ControllerLateral_B->Add = 0.0;
        ControllerLateral_B->diff1 = 0.0;
        ControllerLateral_B->FilterCoefficient_o = 0.0;
        ControllerLateral_B->Add1 = 0.0;
        ControllerLateral_B->FilterCoefficient_n = 0.0;
        ControllerLateral_B->Gain2 = 0.0;
        ControllerLateral_B->Gain9 = 0.0;
        ControllerLateral_B->Gain10_e = 0.0;
        ControllerLateral_B->Add2 = 0.0;
        ControllerLateral_B->FilterCoefficient_p = 0.0;
        ControllerLateral_B->Add6 = 0.0;
        ControllerLateral_B->Gain10_o = 0.0;
        ControllerLateral_B->diff2_k = 0.0;
        ControllerLateral_B->FilterCoefficient_e = 0.0;
        ControllerLateral_B->Add_c = 0.0;
        ControllerLateral_B->diff1_k = 0.0;
        ControllerLateral_B->FilterCoefficient_ow = 0.0;
        ControllerLateral_B->Add1_b = 0.0;
        ControllerLateral_B->FilterCoefficient_f = 0.0;
        ControllerLateral_B->Gain10_ol = 0.0;
        ControllerLateral_B->Add2_a = 0.0;
        ControllerLateral_B->FilterCoefficient_k = 0.0;
        ControllerLateral_B->Add6_g = 0.0;
        ControllerLateral_B->TmpSignalConversionAtDelay2Inport1[0] = 0.0;
        ControllerLateral_B->TmpSignalConversionAtDelay2Inport1[1] = 0.0;
        ControllerLateral_B->TmpSignalConversionAtDelay1Inport1[0] = 0.0;
        ControllerLateral_B->TmpSignalConversionAtDelay1Inport1[1] = 0.0;
        ControllerLateral_B->Gain_k = 0.0;
        ControllerLateral_B->Switch3_h = 0.0;
        ControllerLateral_B->MovingAverage1_pnaevvfpg.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pnaevvfpgh5.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pnaevvfp.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pnaevvfpgh.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pnaevvf.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pnaevvfpg.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pnaevv.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pnaevvfp.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pnaevvf.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pnaev.MovingAverage1 = 0.0;
        ControllerLateral_B->MovingAverage_pnaevv.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pnaev.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pnae.MovingAverage1 = 0.0;
        ControllerLateral_B->MovingAverage_pnae.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pna.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pna.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_pn.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_pn.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1_p.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage_p.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage1.MovingAverage = 0.0;
        ControllerLateral_B->MovingAverage.MovingAverage = 0.0;
      }

      /* states (dwork) */
      (void) ClearDWork((void *)ControllerLateral_DW, 0,
                        sizeof(DW_ControllerLateral_T));
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator1_DSTATE = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_l = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator1_DSTATE_g = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_d = 0.0;
      ControllerLateral_DW->Delay1_DSTATE[0] = 0.0;
      ControllerLateral_DW->Delay1_DSTATE[1] = 0.0;
      ControllerLateral_DW->DelayInput1_DSTATE = 0.0;
      ControllerLateral_DW->Integrator_DSTATE = 0.0;
      ControllerLateral_DW->UD_DSTATE = 0.0;

      {
        int32_T i;
        for (i = 0; i < 400; i++) {
          ControllerLateral_DW->Delay1_DSTATE_b[i] = 0.0;
        }
      }

      ControllerLateral_DW->Integrator_DSTATE_n = 0.0;
      ControllerLateral_DW->Filter_DSTATE = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_o = 0.0;
      ControllerLateral_DW->UD_DSTATE_o = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_m = 0.0;
      ControllerLateral_DW->Filter_DSTATE_a = 0.0;
      ControllerLateral_DW->Delay2_DSTATE = 0.0;
      ControllerLateral_DW->Delay2_DSTATE_i = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_f = 0.0;
      ControllerLateral_DW->Delay1_DSTATE_f = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_b = 0.0;
      ControllerLateral_DW->Delay_DSTATE[0] = 0.0;
      ControllerLateral_DW->Delay_DSTATE[1] = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator1_DSTATE_b = 0.0;
      ControllerLateral_DW->Delay1_DSTATE_j = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_e = 0.0;
      ControllerLateral_DW->Delay_DSTATE_g[0] = 0.0;
      ControllerLateral_DW->Delay_DSTATE_g[1] = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator1_DSTATE_n = 0.0;
      ControllerLateral_DW->Delay2_DSTATE_f[0] = 0.0;
      ControllerLateral_DW->Delay2_DSTATE_f[1] = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_n = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_g = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_m1 = 0.0;
      ControllerLateral_DW->Filter_DSTATE_d = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_ok = 0.0;
      ControllerLateral_DW->Filter_DSTATE_b = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_f = 0.0;
      ControllerLateral_DW->Filter_DSTATE_dy = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_or = 0.0;
      ControllerLateral_DW->Filter_DSTATE_g = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_fq = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_o = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_b = 0.0;
      ControllerLateral_DW->Filter_DSTATE_a1 = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_a = 0.0;
      ControllerLateral_DW->Filter_DSTATE_n = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_p = 0.0;
      ControllerLateral_DW->Filter_DSTATE_dv = 0.0;
      ControllerLateral_DW->Integrator_DSTATE_i = 0.0;
      ControllerLateral_DW->Filter_DSTATE_b5 = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator_DSTATE_ls = 0.0;
      ControllerLateral_DW->DiscreteTimeIntegrator1_DSTATE_m = 0.0;
      ControllerLateral_DW->Memory_PreviousInput = 0.0;
      ControllerLateral_DW->Memory1_PreviousInput = 0.0;
      ControllerLateral_DW->Memory_PreviousInput_k = 0.0;
      ControllerLateral_DW->Memory1_PreviousInput_n = 0.0;
      ControllerLateral_DW->Memory_PreviousInput_d = 0.0;
      ControllerLateral_DW->Memory1_PreviousInput_g = 0.0;
      ControllerLateral_DW->Memory_PreviousInput_l = 0.0;
      ControllerLateral_DW->Memory1_PreviousInput_d = 0.0;
      ControllerLateral_DW->mode_old = 0.0;
      ControllerLateral_DW->t_old = 0.0;
      ControllerLateral_DW->mode_memory_old = 0.0;

      /* external inputs */
      (void)memset(ControllerLateral_U, 0, sizeof(ExtU_ControllerLateral_T));
      ControllerLateral_U->G_A2 = 0.0;
      ControllerLateral_U->G_B2 = 0.0;
      ControllerLateral_U->G_C2 = 0.0;
      ControllerLateral_U->G_D2 = 0.0;
      ControllerLateral_U->motor1 = 0.0;
      ControllerLateral_U->motor2 = 0.0;
      ControllerLateral_U->hems1 = 0.0;
      ControllerLateral_U->hems2 = 0.0;
      ControllerLateral_U->hems3 = 0.0;
      ControllerLateral_U->hems4 = 0.0;
      ControllerLateral_U->I_Front_m = 0.0;
      ControllerLateral_U->I_Back_m = 0.0;
      ControllerLateral_U->LateralAxisState = 0.0;
      ControllerLateral_U->VrF = 0.0;
      ControllerLateral_U->VrB = 0.0;
      ControllerLateral_U->VtF = 0.0;
      ControllerLateral_U->VtB = 0.0;
      ControllerLateral_U->IMU_x = 0.0;
      ControllerLateral_U->IMU_yaw = 0.0;
      ControllerLateral_U->IMU_y = 0.0;

      /* external outputs */
      ControllerLateral_Y->Mode = 0.0;
      ControllerLateral_Y->LinposLateral[0] = 0.0;
      ControllerLateral_Y->LinposLateral[1] = 0.0;
      ControllerLateral_Y->LinposLateral[2] = 0.0;
      ControllerLateral_Y->LinposLateral[3] = 0.0;
      ControllerLateral_Y->Filtered_GapsLateral[0] = 0.0;
      ControllerLateral_Y->Filtered_GapsLateral[1] = 0.0;
      ControllerLateral_Y->Filtered_GapsLateral[2] = 0.0;
      ControllerLateral_Y->Filtered_GapsLateral[3] = 0.0;
      ControllerLateral_Y->ControlSIgnalsLateral[0] = 0.0;
      ControllerLateral_Y->ControlSIgnalsLateral[1] = 0.0;
      ControllerLateral_Y->ControlSignalsLateralFinal[0] = 0.0;
      ControllerLateral_Y->ControlSignalsLateralFinal[1] = 0.0;
      ControllerLateral_Y->OffsetFront = 0.0;
      ControllerLateral_Y->OffsetBack = 0.0;
      ControllerLateral_Y->RefOutFront = 0.0;
      ControllerLateral_Y->RefOutBack = 0.0;
      ControllerLateral_Y->I_Demand_Front = 0.0;
      ControllerLateral_Y->I_Demand_Back = 0.0;
      ControllerLateral_Y->Power_Lat = 0.0;
      ControllerLateral_Y->Power_Lat_avg = 0.0;
      ControllerLateral_Y->Energy_Lat = 0.0;
      ControllerLateral_Y->EMS_F_Front = 0.0;
      ControllerLateral_Y->EMS_F_Back = 0.0;
      ControllerLateral_Y->L_K_i_out[0] = 0.0;
      ControllerLateral_Y->L_K_i_out[1] = 0.0;
      ControllerLateral_Y->uncapped_current = 0.0;
      ControllerLateral_Y->LS_mode_vert = 0.0;
      ControllerLateral_Y->Complementary_B = 0.0;
      ControllerLateral_Y->Complementary_D = 0.0;
      ControllerLateral_Y->x_speed = 0.0;
      ControllerLateral_Y->x_location = 0.0;
      ControllerLateral_Y->Complementary_A = 0.0;
      ControllerLateral_Y->Complementary_C = 0.0;
      ControllerLateral_Y->Inertia = 0.0;

      /* previous zero-crossing states */
      {
        ControllerLateral_PrevZCX->UD_Reset_ZCE = UNINITIALIZED_ZCSIG;
        ControllerLateral_PrevZCX->UD_Reset_ZCE_d = UNINITIALIZED_ZCSIG;
      }

      ControllerLateral_initialize((RT_MODEL_ControllerLateral_T*)
        self->modelData);
    }

    static void CSimulinkCoreControllerLateral_Output(PmpInternal::
      DynamicLibrary::ISimulink* intf)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      ControllerLateral_output((RT_MODEL_ControllerLateral_T*) self->modelData);
    }

    static void CSimulinkCoreControllerLateral_Update(PmpInternal::
      DynamicLibrary::ISimulink* intf)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      ControllerLateral_update((RT_MODEL_ControllerLateral_T*) self->modelData);
    }

    static void CSimulinkCoreControllerLateral_Terminate(PmpInternal::
      DynamicLibrary::ISimulink* intf)
    {
      CSimulinkCoreControllerLateral* self =
        static_cast<CSimulinkCoreControllerLateral*>(intf);
      free(self->modelData);
    }

    static uint32_t CSimulinkCoreControllerLateral_GetInputsDataSize(PmpInternal::
      DynamicLibrary::ISimulink*)
    {
      return sizeof(ExtU_ControllerLateral_T);
    }

    static uint32_t CSimulinkCoreControllerLateral_GetOutputsDataSize
      (PmpInternal::DynamicLibrary::ISimulink*)
    {
      return sizeof(ExtY_ControllerLateral_T);
    }

    static uint32_t CSimulinkCoreControllerLateral_GetTestpointsDataSize
      (PmpInternal::DynamicLibrary::ISimulink*)
    {
      return sizeof(B_ControllerLateral_T);
    }

    static uint32_t CSimulinkCoreControllerLateral_GetParametersDataSize
      (PmpInternal::DynamicLibrary::ISimulink* )
    {
      return sizeof(InstP_ControllerLateral_T);
    }

    static uint32_t CSimulinkCoreControllerLateral_GetUpdatableDataSize
      (PmpInternal::DynamicLibrary::ISimulink*, const char*)
    {
      return 0;
    }

    static uint32_t CSimulinkCoreControllerLateral_GetEventsDataSize(PmpInternal::
      DynamicLibrary::ISimulink*)
    {
      return 0;
    }

    static const SNamedSignalInfo inputOffsets[21] = {
      { "G_A2", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, G_A2),
          EDataTypeDouble } },

      { "G_B2", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, G_B2),
          EDataTypeDouble } },

      { "G_C2", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, G_C2),
          EDataTypeDouble } },

      { "G_D2", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, G_D2),
          EDataTypeDouble } },

      { "motor1", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          motor1), EDataTypeDouble } },

      { "motor2", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          motor2), EDataTypeDouble } },

      { "hems1", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          hems1), EDataTypeDouble } },

      { "hems2", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          hems2), EDataTypeDouble } },

      { "hems3", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          hems3), EDataTypeDouble } },

      { "hems4", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          hems4), EDataTypeDouble } },

      { "I_Front_m", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          I_Front_m), EDataTypeDouble } },

      { "I_Back_m", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          I_Back_m), EDataTypeDouble } },

      { "LateralAxisState", { ESimulinkStructsInput, offsetof
          (ExtU_ControllerLateral_T, LateralAxisState), EDataTypeDouble } },

      { "VrF", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, VrF),
          EDataTypeDouble } },

      { "VrB", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, VrB),
          EDataTypeDouble } },

      { "VtF", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, VtF),
          EDataTypeDouble } },

      { "VtB", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T, VtB),
          EDataTypeDouble } },

      { "IMU_x", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          IMU_x), EDataTypeDouble } },

      { "IMU_yaw", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          IMU_yaw), EDataTypeDouble } },

      { "IMU_y", { ESimulinkStructsInput, offsetof(ExtU_ControllerLateral_T,
          IMU_y), EDataTypeDouble } },

      { "PropulsionOn", { ESimulinkStructsInput, offsetof
          (ExtU_ControllerLateral_T, PropulsionOn), EDataTypeBool } },
    };

    static EResult CSimulinkCoreControllerLateral_GetInputInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char* name, SSignalInfo& info)
    {
      for (unsigned int i = 0; i < 21; ++i) {
        if (strcmp(name, inputOffsets[i].Name) == 0) {
          info = inputOffsets[i].Info;
          return EResultOk;
        }
      }

      return EResultNonExistant;
    }

    static const SNamedSignalInfo outputOffsets[35] = {
      { "Mode", { ESimulinkStructsOutput, offsetof(ExtY_ControllerLateral_T,
          Mode), EDataTypeDouble } },

      { "LinposLateral_0", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, LinposLateral[0]), EDataTypeDouble } },

      { "LinposLateral_1", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, LinposLateral[1]), EDataTypeDouble } },

      { "LinposLateral_2", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, LinposLateral[2]), EDataTypeDouble } },

      { "LinposLateral_3", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, LinposLateral[3]), EDataTypeDouble } },

      { "Filtered_GapsLateral_0", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Filtered_GapsLateral[0]), EDataTypeDouble }
      },

      { "Filtered_GapsLateral_1", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Filtered_GapsLateral[1]), EDataTypeDouble }
      },

      { "Filtered_GapsLateral_2", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Filtered_GapsLateral[2]), EDataTypeDouble }
      },

      { "Filtered_GapsLateral_3", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Filtered_GapsLateral[3]), EDataTypeDouble }
      },

      { "ControlSIgnalsLateral_0", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, ControlSIgnalsLateral[0]), EDataTypeDouble
        } },

      { "ControlSIgnalsLateral_1", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, ControlSIgnalsLateral[1]), EDataTypeDouble
        } },

      { "ControlSignalsLateralFinal_0", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, ControlSignalsLateralFinal[0]),
          EDataTypeDouble } },

      { "ControlSignalsLateralFinal_1", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, ControlSignalsLateralFinal[1]),
          EDataTypeDouble } },

      { "OffsetFront", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, OffsetFront), EDataTypeDouble } },

      { "OffsetBack", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, OffsetBack), EDataTypeDouble } },

      { "RefOutFront", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, RefOutFront), EDataTypeDouble } },

      { "RefOutBack", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, RefOutBack), EDataTypeDouble } },

      { "I_Demand_Front", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, I_Demand_Front), EDataTypeDouble } },

      { "I_Demand_Back", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, I_Demand_Back), EDataTypeDouble } },

      { "Power_Lat", { ESimulinkStructsOutput, offsetof(ExtY_ControllerLateral_T,
          Power_Lat), EDataTypeDouble } },

      { "Power_Lat_avg", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Power_Lat_avg), EDataTypeDouble } },

      { "Energy_Lat", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Energy_Lat), EDataTypeDouble } },

      { "EMS_F_Front", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, EMS_F_Front), EDataTypeDouble } },

      { "EMS_F_Back", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, EMS_F_Back), EDataTypeDouble } },

      { "L_K_i_out_0", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, L_K_i_out[0]), EDataTypeDouble } },

      { "L_K_i_out_1", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, L_K_i_out[1]), EDataTypeDouble } },

      { "uncapped_current", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, uncapped_current), EDataTypeDouble } },

      { "LS_mode_vert", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, LS_mode_vert), EDataTypeDouble } },

      { "Complementary_B", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Complementary_B), EDataTypeDouble } },

      { "Complementary_D", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Complementary_D), EDataTypeDouble } },

      { "x_speed", { ESimulinkStructsOutput, offsetof(ExtY_ControllerLateral_T,
          x_speed), EDataTypeDouble } },

      { "x_location", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, x_location), EDataTypeDouble } },

      { "Complementary_A", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Complementary_A), EDataTypeDouble } },

      { "Complementary_C", { ESimulinkStructsOutput, offsetof
          (ExtY_ControllerLateral_T, Complementary_C), EDataTypeDouble } },

      { "Inertia", { ESimulinkStructsOutput, offsetof(ExtY_ControllerLateral_T,
          Inertia), EDataTypeDouble } },
    };

    static EResult CSimulinkCoreControllerLateral_GetOutputInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char* name, SSignalInfo& info)
    {
      for (unsigned int i = 0; i < 35; ++i) {
        if (strcmp(name, outputOffsets[i].Name) == 0) {
          info = outputOffsets[i].Info;
          return EResultOk;
        }
      }

      return EResultNonExistant;
    }

    static EResult CSimulinkCoreControllerLateral_GetTestpointInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char*, SSignalInfo&)
    {
      return EResultNonExistant;
    }

    static const SNamedSignalInfo parameterOffsets[51] = {
      { "BackGain", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, BackGain), EDataTypeDouble } },

      { "BeamErrorTime", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, BeamErrorTime), EDataTypeDouble } },

      { "CurrentIntegralLat", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, CurrentIntegralLat), EDataTypeDouble } },

      { "ForgetFactor_Highpass_Lat", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, ForgetFactor_Highpass_Lat),
          EDataTypeDouble } },

      { "FrontGain", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, FrontGain), EDataTypeDouble } },

      { "LS_curved_AG", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LS_curved_AG), EDataTypeDouble } },

      { "LS_mode", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LS_mode), EDataTypeDouble } },

      { "LS_straight_AG", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LS_straight_AG), EDataTypeDouble } },

      { "L_K_d", { ESimulinkStructsParameter, offsetof(InstP_ControllerLateral_T,
          L_K_d), EDataTypeDouble } },

      { "L_K_i", { ESimulinkStructsParameter, offsetof(InstP_ControllerLateral_T,
          L_K_i), EDataTypeDouble } },

      { "L_K_p", { ESimulinkStructsParameter, offsetof(InstP_ControllerLateral_T,
          L_K_p), EDataTypeDouble } },

      { "L_T_c", { ESimulinkStructsParameter, offsetof(InstP_ControllerLateral_T,
          L_T_c), EDataTypeDouble } },

      { "LandingTime", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LandingTime), EDataTypeDouble } },

      { "LateralBeamOffsets", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralBeamOffsets), EDataTypeDouble } },

      { "LateralBeamOffsetsBackDelay", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralBeamOffsetsBackDelay),
          EDataTypeDouble } },

      { "LateralBeamOffsetsFactor", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralBeamOffsetsFactor), EDataTypeDouble
        } },

      { "LateralDoubleFilter", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralDoubleFilter), EDataTypeDouble } },

      { "LateralForgettingFactor", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralForgettingFactor), EDataTypeDouble
        } },

      { "LateralOffsetsHEMSMotor_0", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralOffsetsHEMSMotor[0]),
          EDataTypeDouble } },

      { "LateralOffsetsHEMSMotor_1", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralOffsetsHEMSMotor[1]),
          EDataTypeDouble } },

      { "LateralOffsetsHEMSMotor_2", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralOffsetsHEMSMotor[2]),
          EDataTypeDouble } },

      { "LateralOffsetsHEMSMotor_3", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralOffsetsHEMSMotor[3]),
          EDataTypeDouble } },

      { "LateralOffsetsHEMSMotor_4", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralOffsetsHEMSMotor[4]),
          EDataTypeDouble } },

      { "LateralOperatingMode", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralOperatingMode), EDataTypeDouble } },

      { "LateralSineSwitches_0", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralSineSwitches[0]), EDataTypeDouble }
      },

      { "LateralSineSwitches_1", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, LateralSineSwitches[1]), EDataTypeDouble }
      },

      { "M_f", { ESimulinkStructsParameter, offsetof(InstP_ControllerLateral_T,
          M_f), EDataTypeDouble } },

      { "Mass", { ESimulinkStructsParameter, offsetof(InstP_ControllerLateral_T,
          Mass), EDataTypeDouble } },

      { "MeasureCurrent", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, MeasureCurrent), EDataTypeDouble } },

      { "PodLength", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, PodLength), EDataTypeDouble } },

      { "PodWidth", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, PodWidth), EDataTypeDouble } },

      { "PolarityBack", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, PolarityBack), EDataTypeDouble } },

      { "PolarityFront", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, PolarityFront), EDataTypeDouble } },

      { "ReferenceLateralOffsets_0", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, ReferenceLateralOffsets[0]),
          EDataTypeDouble } },

      { "ReferenceLateralOffsets_1", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, ReferenceLateralOffsets[1]),
          EDataTypeDouble } },

      { "ReferenceMass", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, ReferenceMass), EDataTypeDouble } },

      { "ResetComplementary", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, ResetComplementary), EDataTypeDouble } },

      { "RunTime", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, RunTime), EDataTypeDouble } },

      { "SemiCentralized", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, SemiCentralized), EDataTypeDouble } },

      { "SineTime", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, SineTime), EDataTypeDouble } },

      { "StartupTime", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, StartupTime), EDataTypeDouble } },

      { "StopDeIntegral", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, StopDeIntegral), EDataTypeDouble } },

      { "UseBothEMS", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, UseBothEMS), EDataTypeDouble } },

      { "UseComplementaryBD", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, UseComplementaryBD), EDataTypeDouble } },

      { "kalman_xdotdot_gain", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, kalman_xdotdot_gain), EDataTypeDouble } },

      { "kalman_yawdot_gain", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, kalman_yawdot_gain), EDataTypeDouble } },

      { "kalman_ydotdot_gain", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, kalman_ydotdot_gain), EDataTypeDouble } },

      { "lat_zero_reset", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, lat_zero_reset), EDataTypeDouble } },

      { "lateral_over_vertical_force_hems", { ESimulinkStructsParameter,
          offsetof(InstP_ControllerLateral_T, lateral_over_vertical_force_hems),
          EDataTypeDouble } },

      { "lateral_over_vertical_force_motor", { ESimulinkStructsParameter,
          offsetof(InstP_ControllerLateral_T, lateral_over_vertical_force_motor),
          EDataTypeDouble } },

      { "t_trans", { ESimulinkStructsParameter, offsetof
          (InstP_ControllerLateral_T, t_trans), EDataTypeDouble } },
    };

    static EResult CSimulinkCoreControllerLateral_GetParameterInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char* name, SSignalInfo& info)
    {
      for (unsigned int i = 0; i < 51; ++i) {
        if (strcmp(name, parameterOffsets[i].Name) == 0) {
          info = parameterOffsets[i].Info;
          return EResultOk;
        }
      }

      return EResultNonExistant;
    }

    static EResult CSimulinkCoreControllerLateral_GetUpdatableInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char*, SUpdatableInfo&)
    {
      return EResultNonExistant;
    }

    static EResult CSimulinkCoreControllerLateral_GetEventInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char*, SEventInfo&)
    {
      return EResultNonExistant;
    }

    static EResult CSimulinkCoreControllerLateral_GetStateInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const char*, SSignalInfo&)
    {
      return EResultNonExistant;
    }

    struct OffsetAdmin
    {
      uint32_t Offset;
      uint32_t Size;
    };

    static void ClearDWork(void* ptr, int value, size_t num)
    {
      memset(ptr, value, num);
    }

    static double CSimulinkCoreControllerLateral_GetSamplePeriod(PmpInternal::
      DynamicLibrary::ISimulink*)
    {
      return 0.00025;
    }

    static const SReflectionInfo reflectionInfo[108] = {
      { "G_A2", ESimulinkStructsInput },

      { "G_B2", ESimulinkStructsInput },

      { "G_C2", ESimulinkStructsInput },

      { "G_D2", ESimulinkStructsInput },

      { "motor1", ESimulinkStructsInput },

      { "motor2", ESimulinkStructsInput },

      { "hems1", ESimulinkStructsInput },

      { "hems2", ESimulinkStructsInput },

      { "hems3", ESimulinkStructsInput },

      { "hems4", ESimulinkStructsInput },

      { "I_Front_m", ESimulinkStructsInput },

      { "I_Back_m", ESimulinkStructsInput },

      { "LateralAxisState", ESimulinkStructsInput },

      { "VrF", ESimulinkStructsInput },

      { "VrB", ESimulinkStructsInput },

      { "VtF", ESimulinkStructsInput },

      { "VtB", ESimulinkStructsInput },

      { "IMU_x", ESimulinkStructsInput },

      { "IMU_yaw", ESimulinkStructsInput },

      { "IMU_y", ESimulinkStructsInput },

      { "PropulsionOn", ESimulinkStructsInput },

      { "Mode", ESimulinkStructsOutput },

      { "LinposLateral_0", ESimulinkStructsOutput },

      { "LinposLateral_1", ESimulinkStructsOutput },

      { "LinposLateral_2", ESimulinkStructsOutput },

      { "LinposLateral_3", ESimulinkStructsOutput },

      { "Filtered_GapsLateral_0", ESimulinkStructsOutput },

      { "Filtered_GapsLateral_1", ESimulinkStructsOutput },

      { "Filtered_GapsLateral_2", ESimulinkStructsOutput },

      { "Filtered_GapsLateral_3", ESimulinkStructsOutput },

      { "ControlSIgnalsLateral_0", ESimulinkStructsOutput },

      { "ControlSIgnalsLateral_1", ESimulinkStructsOutput },

      { "ControlSignalsLateralFinal_0", ESimulinkStructsOutput },

      { "ControlSignalsLateralFinal_1", ESimulinkStructsOutput },

      { "OffsetFront", ESimulinkStructsOutput },

      { "OffsetBack", ESimulinkStructsOutput },

      { "RefOutFront", ESimulinkStructsOutput },

      { "RefOutBack", ESimulinkStructsOutput },

      { "I_Demand_Front", ESimulinkStructsOutput },

      { "I_Demand_Back", ESimulinkStructsOutput },

      { "Power_Lat", ESimulinkStructsOutput },

      { "Power_Lat_avg", ESimulinkStructsOutput },

      { "Energy_Lat", ESimulinkStructsOutput },

      { "EMS_F_Front", ESimulinkStructsOutput },

      { "EMS_F_Back", ESimulinkStructsOutput },

      { "L_K_i_out_0", ESimulinkStructsOutput },

      { "L_K_i_out_1", ESimulinkStructsOutput },

      { "uncapped_current", ESimulinkStructsOutput },

      { "LS_mode_vert", ESimulinkStructsOutput },

      { "Complementary_B", ESimulinkStructsOutput },

      { "Complementary_D", ESimulinkStructsOutput },

      { "x_speed", ESimulinkStructsOutput },

      { "x_location", ESimulinkStructsOutput },

      { "Complementary_A", ESimulinkStructsOutput },

      { "Complementary_C", ESimulinkStructsOutput },

      { "Inertia", ESimulinkStructsOutput },

      { "BackGain", ESimulinkStructsParameter },

      { "BeamErrorTime", ESimulinkStructsParameter },

      { "CurrentIntegralLat", ESimulinkStructsParameter },

      { "ForgetFactor_Highpass_Lat", ESimulinkStructsParameter },

      { "FrontGain", ESimulinkStructsParameter },

      { "LS_curved_AG", ESimulinkStructsParameter },

      { "LS_mode", ESimulinkStructsParameter },

      { "LS_straight_AG", ESimulinkStructsParameter },

      { "L_K_d", ESimulinkStructsParameter },

      { "L_K_i", ESimulinkStructsParameter },

      { "L_K_p", ESimulinkStructsParameter },

      { "L_T_c", ESimulinkStructsParameter },

      { "LandingTime", ESimulinkStructsParameter },

      { "LateralBeamOffsets", ESimulinkStructsParameter },

      { "LateralBeamOffsetsBackDelay", ESimulinkStructsParameter },

      { "LateralBeamOffsetsFactor", ESimulinkStructsParameter },

      { "LateralDoubleFilter", ESimulinkStructsParameter },

      { "LateralForgettingFactor", ESimulinkStructsParameter },

      { "LateralOffsetsHEMSMotor_0", ESimulinkStructsParameter },

      { "LateralOffsetsHEMSMotor_1", ESimulinkStructsParameter },

      { "LateralOffsetsHEMSMotor_2", ESimulinkStructsParameter },

      { "LateralOffsetsHEMSMotor_3", ESimulinkStructsParameter },

      { "LateralOffsetsHEMSMotor_4", ESimulinkStructsParameter },

      { "LateralOperatingMode", ESimulinkStructsParameter },

      { "LateralSineSwitches_0", ESimulinkStructsParameter },

      { "LateralSineSwitches_1", ESimulinkStructsParameter },

      { "M_f", ESimulinkStructsParameter },

      { "Mass", ESimulinkStructsParameter },

      { "MeasureCurrent", ESimulinkStructsParameter },

      { "PodLength", ESimulinkStructsParameter },

      { "PodWidth", ESimulinkStructsParameter },

      { "PolarityBack", ESimulinkStructsParameter },

      { "PolarityFront", ESimulinkStructsParameter },

      { "ReferenceLateralOffsets_0", ESimulinkStructsParameter },

      { "ReferenceLateralOffsets_1", ESimulinkStructsParameter },

      { "ReferenceMass", ESimulinkStructsParameter },

      { "ResetComplementary", ESimulinkStructsParameter },

      { "RunTime", ESimulinkStructsParameter },

      { "SemiCentralized", ESimulinkStructsParameter },

      { "SineTime", ESimulinkStructsParameter },

      { "StartupTime", ESimulinkStructsParameter },

      { "StopDeIntegral", ESimulinkStructsParameter },

      { "UseBothEMS", ESimulinkStructsParameter },

      { "UseComplementaryBD", ESimulinkStructsParameter },

      { "kalman_xdotdot_gain", ESimulinkStructsParameter },

      { "kalman_yawdot_gain", ESimulinkStructsParameter },

      { "kalman_ydotdot_gain", ESimulinkStructsParameter },

      { "lat_zero_reset", ESimulinkStructsParameter },

      { "lateral_over_vertical_force_hems", ESimulinkStructsParameter },

      { "lateral_over_vertical_force_motor", ESimulinkStructsParameter },

      { "t_trans", ESimulinkStructsParameter },

      // end with invalid entry as last
      { "", ESimulinkStructsInvalid },
    };

    static EResult CSimulinkCoreControllerLateral_GetReflectionInfo(PmpInternal::
      DynamicLibrary::ISimulink*, const SReflectionInfo*& info)
    {
      info = reflectionInfo;
      return EResultOk;
    }

    static struct PmpInternal::DynamicLibrary::ISimulinkVTable
      ISimulinkControllerLateral = {
      CSimulinkCoreControllerLateral_GetInputsDataSize,
      CSimulinkCoreControllerLateral_GetOutputsDataSize,
      CSimulinkCoreControllerLateral_GetTestpointsDataSize,
      CSimulinkCoreControllerLateral_GetParametersDataSize,
      CSimulinkCoreControllerLateral_GetUpdatableDataSize,
      CSimulinkCoreControllerLateral_GetEventsDataSize,
      CSimulinkCoreControllerLateral_GetStateDataSize,
      CSimulinkCoreControllerLateral_SetInputsDataAddress,
      CSimulinkCoreControllerLateral_SetOutputsDataAddress,
      CSimulinkCoreControllerLateral_SetTestpointsDataAddress,
      CSimulinkCoreControllerLateral_SetParametersDataAddress,
      CSimulinkCoreControllerLateral_SetUpdatableDataAddress,
      CSimulinkCoreControllerLateral_SetEventsDataAddress,
      CSimulinkCoreControllerLateral_SetStateDataAddress,
      CSimulinkCoreControllerLateral_GetInputInfo,
      CSimulinkCoreControllerLateral_GetOutputInfo,
      CSimulinkCoreControllerLateral_GetTestpointInfo,
      CSimulinkCoreControllerLateral_GetParameterInfo,
      CSimulinkCoreControllerLateral_GetUpdatableInfo,
      CSimulinkCoreControllerLateral_GetEventInfo,
      CSimulinkCoreControllerLateral_GetStateInfo,
      CSimulinkCoreControllerLateral_GetSamplePeriod,
      CSimulinkCoreControllerLateral_Init,
                // PreInit is not known for simulink. Full init is done instead.
      CSimulinkCoreControllerLateral_Init,
      CSimulinkCoreControllerLateral_Update,
      CSimulinkCoreControllerLateral_Output,
      CSimulinkCoreControllerLateral_Terminate,
      CSimulinkCoreControllerLateral_GetReflectionInfo
    };

    CSimulinkCoreControllerLateral::CSimulinkCoreControllerLateral(void
      * modelData)
      : modelData(modelData)
    {
      vtable = &ISimulinkControllerLateral;
      memset(&events, 0, sizeof(events));
    }

    static ISimulink * createCoreControllerLateral()
    {
      RT_MODEL_ControllerLateral_T * ControllerLateral_M =
        (RT_MODEL_ControllerLateral_T*) malloc(sizeof
        (RT_MODEL_ControllerLateral_T));
      if (ControllerLateral_M == NULL) {
        return NULL;
      }

      (void) memset((char*) ControllerLateral_M, 0, sizeof
                    (RT_MODEL_ControllerLateral_T));

      /* previous zero-crossing states */
      {
        PrevZCX_ControllerLateral_T *zc = (PrevZCX_ControllerLateral_T *) malloc
          (sizeof(PrevZCX_ControllerLateral_T));
        rt_VALIDATE_MEMORY(ControllerLateral_M,zc);
        ControllerLateral_M->prevZCSigState = (zc);
      }

      return new CSimulinkCoreControllerLateral((void*) ControllerLateral_M);
    }

    PmpInternal::DynamicLibrary::ISimulink * InternalCreateControllerLateral
      (PmpInternal::DynamicLibrary::PmpCallbacks * callbacks)
    {
      if (callbacks) {
        // Assignment of large structs is by some compilers translated to memcpy. However, that function is not yet available. So instead use the memcpy in the callback
        callbacks->memcpy(&PmpInternal::DynamicLibrary::libCallbacks, callbacks,
                          sizeof(PmpInternal::DynamicLibrary::libCallbacks));
        uintptr_t * startAddr = (uintptr_t*) callbacks;
        for (uint32_t i = 0; i < sizeof(PmpInternal::DynamicLibrary::
              libCallbacks) / sizeof(uintptr_t*); ++i) {
          if (startAddr == NULL) {
            callbacks->fatalError("Missing function");
          }

          ++startAddr;
        }
      } else {
        memset(&PmpInternal::DynamicLibrary::libCallbacks, 0, sizeof(PmpInternal::
                DynamicLibrary::libCallbacks));
      }

      return createCoreControllerLateral();
    }
  }                                    // Namespace: DynamicLibrary
}                                      // Namespace: PmpInternal

// For built in blocks these do not have to be external symbols on the dll
#ifndef BUILT_IN_BLOCK

PMP_DLL_ATTR
  uint32_t GetVersion()
{
  return PmpInternal::DynamicLibrary::major_version;
}

PMP_DLL_ATTR
  void GetIntfVersion(uint32_t* major, uint32_t* minor)
{
  *major = PmpInternal::DynamicLibrary::major_version;
  *minor = PmpInternal::DynamicLibrary::minor_version;
}

PMP_DLL_ATTR
  PmpInternal::DynamicLibrary::ISimulink * Create(PmpInternal::DynamicLibrary::
  PmpCallbacks * callbacks)
{
  return PmpInternal::DynamicLibrary::InternalCreateControllerLateral(callbacks);
}

#else

// registrar is only used in combination with builtin blocks.
#ifdef USE_REGISTRAR
#include "simulink_registrar.h"

class StaticInit
{
 public:
  StaticInit()
  {
    SimulinkRegistrar_Add("ControllerLateral", &PmpInternal::DynamicLibrary::
                          InternalCreateControllerLateral);
  }
};

static StaticInit staticInit;

#else

extern "C" VISIBLE PmpInternal::DynamicLibrary::ISimulink *
  CreateSimulinkControllerLateral(PmpInternal::DynamicLibrary::PmpCallbacks *
  callbacks)
{
  return PmpInternal::DynamicLibrary::InternalCreateControllerLateral(callbacks);
}

#endif
#endif
