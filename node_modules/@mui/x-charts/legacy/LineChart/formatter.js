import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import { stack as d3Stack } from 'd3-shape';
import { getStackingGroups } from '../internals/stackSeries';
import defaultizeValueFormatter from '../internals/defaultizeValueFormatter';
var warnedOnce = false;

// For now it's a copy past of bar charts formatter, but maybe will diverge later
var formatter = function formatter(params, dataset) {
  var _ref;
  var seriesOrder = params.seriesOrder,
    series = params.series;
  var stackingGroups = getStackingGroups(_extends({}, params, {
    defaultStrategy: {
      stackOffset: 'none'
    }
  }));

  // Create a data set with format adapted to d3
  var d3Dataset = (_ref = dataset) != null ? _ref : [];
  seriesOrder.forEach(function (id) {
    var data = series[id].data;
    if (data !== undefined) {
      data.forEach(function (value, index) {
        if (d3Dataset.length <= index) {
          d3Dataset.push(_defineProperty({}, id, value));
        } else {
          d3Dataset[index][id] = value;
        }
      });
    } else if (dataset === undefined && process.env.NODE_ENV !== 'production') {
      throw new Error(["MUI-X-Charts: line series with id='".concat(id, "' has no data."), 'Either provide a data property to the series or use the dataset prop.'].join('\n'));
    }
  });
  var completedSeries = {};
  stackingGroups.forEach(function (stackingGroup) {
    // Get stacked values, and derive the domain
    var ids = stackingGroup.ids,
      stackingOrder = stackingGroup.stackingOrder,
      stackingOffset = stackingGroup.stackingOffset;
    var stackedSeries = d3Stack().keys(ids.map(function (id) {
      // Use dataKey if needed and available
      var dataKey = series[id].dataKey;
      return series[id].data === undefined && dataKey !== undefined ? dataKey : id;
    })).value(function (d, key) {
      var _d$key;
      return (_d$key = d[key]) != null ? _d$key : 0;
    }) // defaultize null value to 0
    .order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach(function (id, index) {
      var dataKey = series[id].dataKey;
      completedSeries[id] = _extends({}, series[id], {
        data: dataKey ? dataset.map(function (data) {
          var value = data[dataKey];
          if (typeof value !== 'number') {
            if (process.env.NODE_ENV !== 'production' && !warnedOnce && value !== null) {
              warnedOnce = true;
              console.error(["MUI-X charts: your dataset key \"".concat(dataKey, "\" is used for plotting line, but contains nonnumerical elements."), 'Line plots only support numbers and null values.']);
            }
            return null;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index].map(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
            a = _ref3[0],
            b = _ref3[1];
          return [a, b];
        })
      });
    });
  });
  return {
    seriesOrder: seriesOrder,
    stackingGroups: stackingGroups,
    series: defaultizeValueFormatter(completedSeries, function (v) {
      return v == null ? void 0 : v.toLocaleString();
    })
  };
};
export default formatter;