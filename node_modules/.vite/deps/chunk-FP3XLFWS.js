import {
  require_jsx_runtime
} from "./chunk-U73TBONF.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/react-speedometer/dist/Speedometer.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());

// node_modules/react-speedometer/dist/context.js
var import_react = __toESM(require_react());
var context_default = (0, import_react.createContext)({
  currentFillAngle: 0,
  radius: 0,
  rotation: 0,
  min: 0,
  max: 0,
  angle: 0,
  lineCap: "butt",
  accentColor: "#00e0ff",
  fontFamily: "helvetica",
  value: 0
});

// node_modules/react-speedometer/dist/Speedometer.js
function Speedometer({ width = 250, height = width, angle = 250, rotation = -angle / 2, value = 0, min = 0, max = 180, lineCap = "butt", accentColor = "#00e0ff", fontFamily = "helvetica", children }) {
  const radius = width / 2;
  const currentFillAngle = (0, import_react2.useMemo)(() => {
    const clampValue = Math.min(max, Math.max(min, Number(value)));
    return angle * (clampValue - min) / (max - min);
  }, [min, max, value, angle]);
  const contextValue = {
    currentFillAngle,
    radius,
    rotation,
    min,
    max,
    angle,
    lineCap,
    accentColor,
    fontFamily,
    value
  };
  return (0, import_jsx_runtime.jsx)(context_default.Provider, { value: contextValue, children: (0, import_jsx_runtime.jsx)("svg", { width, height, children: (0, import_jsx_runtime.jsx)("g", { transform: `rotate(${rotation} ${radius} ${radius})`, children }) }) });
}

// node_modules/react-speedometer/dist/Arc.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// node_modules/react-speedometer/dist/utils.js
var polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
  const angleInRadians = (angleInDegrees - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
};
var getCirclePath = (x, y, radius, startAngle, endAngle) => {
  const start = polarToCartesian(x, y, radius, endAngle * 0.9999);
  const end = polarToCartesian(x, y, radius, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  const d = ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y];
  return d.join(" ");
};

// node_modules/react-speedometer/dist/Arc.js
function Arc({ color = "black", opacity = 0.3, arcWidth = 4, lineCap, ...rest }) {
  const { radius, lineCap: globalLineCap, angle } = (0, import_react3.useContext)(context_default);
  const secondaryPath = (0, import_react3.useMemo)(() => getCirclePath(radius, radius, radius - arcWidth / 2, 0, angle), [radius, arcWidth, angle]);
  return (0, import_jsx_runtime2.jsx)("path", { d: secondaryPath, stroke: color, strokeOpacity: opacity, strokeWidth: arcWidth, strokeLinecap: lineCap || globalLineCap, fill: "transparent", ...rest });
}

// node_modules/react-speedometer/dist/Background.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());
function Background({ angle = 360, color = "black", opacity = 0.5, ...rest }) {
  const { rotation, radius } = (0, import_react4.useContext)(context_default);
  const backgroundStart = rotation + angle / 2;
  const backgroundPath = (0, import_react4.useMemo)(() => getCirclePath(radius, radius, radius, -backgroundStart, -backgroundStart + angle), [radius, backgroundStart, angle]);
  return (0, import_jsx_runtime3.jsx)("path", { d: backgroundPath, fill: color, fillOpacity: opacity, ...rest });
}

// node_modules/react-speedometer/dist/DangerPath.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());
function DangerPath({ color = "#FF3333", angle = 50, arcWidth = 4, lineCap, offset = 6, ...rest }) {
  const { radius, angle: globalAngle, lineCap: globalLineCap } = (0, import_react5.useContext)(context_default);
  const circlePath = (0, import_react5.useMemo)(() => getCirclePath(radius, radius, radius - arcWidth - offset, globalAngle - angle, globalAngle), [radius, globalAngle, angle, arcWidth, offset]);
  return (0, import_jsx_runtime4.jsx)("path", { d: circlePath, stroke: color, strokeWidth: arcWidth, strokeLinecap: lineCap || globalLineCap, fill: "transparent", ...rest });
}

// node_modules/react-speedometer/dist/Indicator.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
function Indicator({ fontSize = 45, color = "white", fontFamily, children, ...rest }) {
  const { value, radius, rotation, fontFamily: globalFontFamily } = (0, import_react6.useContext)(context_default);
  const textProps = {
    transform: `rotate(${360 - rotation}, ${radius}, ${radius})`
  };
  const fixedValue = Number(value).toFixed();
  if (children)
    return children(fixedValue, textProps);
  return (0, import_jsx_runtime5.jsx)("text", { ...textProps, x: radius, y: radius + radius / 2 + 10, textAnchor: "middle", fontSize, fontFamily: fontFamily || globalFontFamily, fill: color, ...rest, children: fixedValue });
}

// node_modules/react-speedometer/dist/Marks.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());
var getMarkPosition = (angle, offset, radius) => {
  return polarToCartesian(radius, radius, radius + offset, angle);
};
function Marks({ step = 10, lineCap = "butt", lineColor = "white", lineOpacity = 1, numbersRadius = 17, fontSize = 18, lineSize = 12, children }) {
  const { rotation, min, max, angle, radius, fontFamily } = (0, import_react7.useContext)(context_default);
  const marks = (0, import_react7.useMemo)(() => {
    const stepsLength = Math.round((max - min) / step);
    const gap = angle / stepsLength;
    return [...Array(stepsLength + 1)].map((val, index) => {
      const actualAngle = gap * index;
      const isEven = index % 2 == 0;
      const size = isEven ? lineSize : lineSize - 5;
      const { x: x1, y: y1 } = getMarkPosition(actualAngle, 0, radius);
      const { x: x2, y: y2 } = getMarkPosition(actualAngle, -size, radius);
      const { x, y } = getMarkPosition(actualAngle, -lineSize - numbersRadius, radius);
      return {
        coordinates: { x1, y1, x2, y2 },
        isEven,
        textProps: { x, y, transform: `rotate(${360 - rotation}, ${x}, ${y})` },
        value: Math.round(index * step + min)
      };
    });
  }, [max, min, step, radius, rotation, angle, lineSize]);
  if (children)
    return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: marks.map(children) });
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: marks.map((mark, i) => (0, import_jsx_runtime6.jsxs)("g", { children: [(0, import_jsx_runtime6.jsx)("line", { ...mark.coordinates, stroke: lineColor, strokeWidth: mark.isEven ? 3 : 2, strokeOpacity: lineOpacity, strokeLinecap: lineCap }), mark.isEven && (0, import_jsx_runtime6.jsx)("text", { ...mark.textProps, fill: "white", textAnchor: "middle", alignmentBaseline: "middle", fontFamily, opacity: 0.8, fontSize, children: mark.value })] }, i)) });
}

// node_modules/react-speedometer/dist/Needle.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());
function Needle({ offset = 25, baseWidth = 6, baseOffset = 18, color = "white", circleRadius = 15, circleColor, strokeLinejoin = "round", children }) {
  const { currentFillAngle, radius, accentColor } = (0, import_react8.useContext)(context_default);
  const bottom = radius + baseOffset;
  const points = `
    ${radius - baseWidth / 2}, ${bottom} ${radius + baseWidth / 2}, ${bottom} ${radius}, ${offset}
  `;
  const defaultNeedle = (0, import_jsx_runtime7.jsxs)("g", { children: [(0, import_jsx_runtime7.jsx)("circle", { r: circleRadius, cx: radius, cy: radius, fill: circleColor || accentColor }), (0, import_jsx_runtime7.jsx)("polygon", { points, fill: color, strokeWidth: "2", stroke: color, style: { strokeLinejoin } })] });
  return (0, import_jsx_runtime7.jsx)("g", { transform: `rotate(${currentFillAngle}, ${radius}, ${radius})`, children: children ? children() : defaultNeedle });
}

// node_modules/react-speedometer/dist/Progress.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());
function Progress({ color, arcWidth = 5, lineCap, ...rest }) {
  const { accentColor, radius, lineCap: globalLineCap, currentFillAngle } = (0, import_react9.useContext)(context_default);
  const progressPath = (0, import_react9.useMemo)(() => getCirclePath(radius, radius, radius - arcWidth / 2, 0, currentFillAngle), [radius, arcWidth, currentFillAngle]);
  return (0, import_jsx_runtime8.jsx)("path", { d: progressPath, stroke: color || accentColor, strokeWidth: arcWidth, strokeLinecap: lineCap || globalLineCap, fill: "transparent", ...rest });
}

// node_modules/react-speedometer/dist/index.js
var dist_default = Speedometer;

export {
  Arc,
  Background,
  DangerPath,
  Indicator,
  Marks,
  Needle,
  Progress,
  dist_default
};
//# sourceMappingURL=chunk-FP3XLFWS.js.map
